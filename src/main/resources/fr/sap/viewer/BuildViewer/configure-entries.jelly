<!--
The MIT License

Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->
<?jelly escape-by-default='true'?>
<!--xmlns:g="glide"-->
<j:jelly xmlns:j="jelly:core" xmlns:st="jelly:stapler" xmlns:d="jelly:define" xmlns:l="/lib/layout" xmlns:t="/lib/hudson" xmlns:f="/lib/form" xmlns:i="jelly:fmt" 
         trim="false" xmlns:g="glide" xmlns:j2="jelly:core" xmlns:g2="null">
    <script type="text/javascript" src="${rootURL}/plugin/viewer/redips.js" />
    <style type="text/css" title="myInnerCSS">
        .redips-drag {
        cursor: move;
        border: 0 solid #FFFFFF;
        }
        
        .redips-trash {
        color: white;
        background-color: #2D4B7A;
        }
        
        div#redips-drag td {
        height: 32px;
        text-align: center;
        font-size: 10pt;
        }
        
        table#stateList {
        width=1920px;
        margin:auto;
        padding:10px;
        }
        
        table#stateList tr td.redips-mark div div.headerStyle {
        background:#9B9EA2;
        line-height:30px;
        font-weight:bold;
        font-size:large;
        }
        
        table#stateList tr td.redips-mark div div.colBackgroundStyle {
        float:left;
        width:300px;
        }
        
        table#stateList tr td.redips-mark div div.colFontColorStyle {
        float:left;
        width:300px;
        }
        
        table#stateList tr td.redips-mark div div.colStateStyle {
        float:left;
        width:300px;
        }
        
        table#stateList tr td.redips-mark div div.colDrahNDropStyle {
        float:left;
        <!--margin-left:50px;-->
        }

        table#stateList tr td div.redips-drag div.colBackgroundStyle {       
        float:left;
        width:300px;
        }
        
        table#stateList tr td div.redips-drag div.colFontColorStyle {
        float:left;
        width:300px;
        }
        
        table#stateList tr td div.redips-drag div.colStateStyle {
        float:left;
        width:300px;
        }
        
        table#stateList tr td div.redips-drag div.colDrahNDropStyle {
        float:left;
        width:50px;
        }
        
    </style>
    
    <script type="text/javascript">
        var redipsInit;
        redipsInit = function () {
        REDIPS.drag.init();
        REDIPS.drag.dropMode = 'switching';
        }
        if (window.addEventListener) {
        window.addEventListener('load', redipsInit, false);
        }
        else if (window.attachEvent) {
        window.attachEvent('onload', redipsInit);
        }
                 
        function addRow(tableId){
        var table = document.getElementById(tableId);
        var row = table.insertRow(table.rows.length-2);
        var cell = row.insertCell(0);
        cell.innerHTML = "&lt;div class=\&quot;redips-drag\&quot;&gt;&lt;div class=\&quot;colStateStyle\&quot;&gt;&lt;input type=\&quot;text\&quot; name=\&quot;ve_state\&quot; value=\&quot;${from.DEFAULT_STATE_NAME}\&quot; /&gt;&lt;/div&gt;&lt;div class=\&quot;colBackgroundStyle\&quot;&gt;&lt;input type=\&quot;color\&quot; name=\&quot;ve_backgroundColor\&quot; value=\&quot;${from.DEFAULT_VE_BACKGROUND_COLOR}\&quot;  /&gt;&lt;/div&gt;&lt;div class=\&quot;colFontColorStyle\&quot;&gt;&lt;input type=\&quot;color\&quot; name=\&quot;ve_fontColor\&quot; value=\&quot;${from.DEFAULT_VE_FONT_COLOR}\&quot; /&gt;&lt;/div&gt;&lt;/div&gt;";
        }
        
        function deleteRow(tableId, stateValue) {
        var table = document.getElementById(tableId);
        for(var i = 0 ; i &lt; table.rows.length ; i++){
        if(table.rows[i].cells[0].innerHTML.match(stateValue) != null){
        document.getElementById(tableId).deleteRow(i);
        }
        }
        }
       
    </script>

    
    <!--URLs-->
    <j:set var="myImagesURL" value="${rootURL}/plugin/viewer/images/"/>
    <j:set var="helpURL" value="/plugin/viewer/help/"/>
    
    <!--Job Filter-->
    <f:section title="${%Job Filters}">
  
        <f:entry title="${%Status Filter}" help="/help/view-config/statusFilter.html">
            <select name="statusFilter" class="setting-input">
                <f:option value="" selected="${it.statusFilter==null}">${%All selected jobs}</f:option>
                <f:option value="1" selected="${it.statusFilter==true}">${%Enabled jobs only}</f:option>
                <f:option value="2" selected="${it.statusFilter==false}">${%Disabled jobs only}</f:option>
            </select>
        </f:entry>
  
        <f:entry title="${%Recurse in subfolders}" field="recurse">
            <f:checkbox id="recurse"/>
        </f:entry>

        <f:entry title="${%Jobs}">
            <div class="listview-jobs">
                <j:forEach var="job" items="${h.getAllTopLevelItems(it.ownerItemGroup)}">
                    <j:set var="spanClass" value=""/>
                    <j:set var="spanStyle" value=""/>
                    <j:if test="${job.parent!=it.ownerItemGroup}">
                        <j:set var="spanClass" value="nested"/>
                        <j:set var="spanStyle" value="${it.recurse?'':'display:none'}"/>
                    </j:if>
                    <span class="${spanClass}" style="${spanStyle}">
                        <f:checkbox name="${job.getRelativeNameFromGroup(it.ownerItemGroup)}" checked="${it.jobNamesContains(job)}" 
                                    title="${h.getRelativeDisplayNameFrom(job,it.ownerItemGroup)}" tooltip="Check ${job.fullName} to include it in the view" json="true"/>
                        <br/>
                    </span>
                </j:forEach>
            </div>
        </f:entry>

<!--        <f:optionalBlock name="useincluderegex" title="${%Use a regular expression to include jobs into the view}"
                         checked="${it.includeRegex != null}" help="/help/view-config/includeregex.html">
            <f:entry title="${%Regular expression}">
                <f:textbox name="includeRegex" field="includeRegex" />
            </f:entry>
        </f:optionalBlock>-->
        
    </f:section>

    



    <!--Build information displayed-->
    <f:section title="${%Build information displayed}">
        
        <f:optionalBlock name="displayCaption" title="${%Display a caption at the top of the view}" help="${helpURL}includecaption.html">
            
            <f:entry title="${%Caption text}" field="captionText"  help="${helpURL}captionText.html">
                <f:textbox name="captionText" field="captionText" />
            </f:entry>
            <f:entry title="${%Caption size}" field="captionSize"  help="${helpURL}captionSize.html">
                <f:textbox name="captionSize" field="captionSize" clazz="required positive-number" default="36" />
            </f:entry>
            
            <f:entry title="${%Caption background color}" field="captionColor" >
                <j:choose>
                    <j:when test="${it.captionColor != null}">
                        <j:set var="varCaptionColor" value="${it.captionColor}"/>
                    </j:when>
                    <j:otherwise>
                        <j:set var="varCaptionColor" value="${from.DEFAULT_CAPTION_BACKGROUND_COLOR}"/>
                    </j:otherwise>
                </j:choose>
                <input type="color" name="captionColor" value="${varCaptionColor}" />
            </f:entry>
            
            <f:entry title="${%Caption text color}" field="captionTextColor" >
                <j:choose>
                    <j:when test="${it.captionTextColor != null}">
                        <j:set var="varCaptionTextColor" value="${it.captionTextColor}"/>
                    </j:when>
                    <j:otherwise>
                        <j:set var="varCaptionTextColor" value="${from.DEFAULT_CAPTION_FONT_COLOR}"/>
                    </j:otherwise>
                </j:choose>
                <input type="color" name="captionTextColor" value="${varCaptionTextColor}" />
            </f:entry>
        </f:optionalBlock>
        
        <f:optionalBlock name="ConfigureColor" title="${%Configure colors}" help="${helpURL}?.html" checked="${it.includeBackgroundColor != null}">
            <f:entry title="${%Background color}" field="backgroundColor"  help="${helpURL}?.html">
                <j:choose>
                    <j:when test="${it.backgroundColor != null}">
                        <j:set var="varBackgroundColor" value="${it.backgroundColor}"/>
                    </j:when>
                    <j:otherwise>
                        <j:set var="varBackgroundColor" value="${from.DEFAULT_BACKGROUND_COLOR}"/>
                    </j:otherwise>
                </j:choose>
                <input type="color" name="backgroundColor" value="${varBackgroundColor}" />
            </f:entry>
        </f:optionalBlock>
        
        <f:entry title="${%States}" field="COLOR_SETTINGS">
            <j:if test="${from.COLOR_SETTINGS == null}">
                <j:invoke on="${from}" method="setDefaultColorSettings">
                    <j:arg type="boolean" value="true" />
                </j:invoke>
            </j:if>
            <form>
                <div >
                    <div id="redips-drag" style="margin-bottom:20px;" >
                        <table id="stateList"  style="width:976px;" >
                            <tr>
                                <td class="redips-mark">
                                    <div>
                                        <div class="colStateStyle headerStyle" >${%State}</div>
                                        <div class="colBackgroundStyle headerStyle">${%Background color}</div>
                                        <div class="colFontColorStyle headerStyle">${%Font color}</div>
                                        <div style="background:#FFFFFF" class="colDrahNDropStyle" ></div>
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <td class="redips-mark" style="height:30px;background:#FFFFFF"></td>
                            </tr>
                            <j:forEach var="state" items="${from.COLOR_SETTINGS}">
                                <tr>
                                    <td>
                                        <div class="redips-drag">
                                            <div class="colStateStyle">
                                                <input type="text" name="ve_state" value="${state.ve_state}" style=""/>
                                            </div>
                                            <div class="colBackgroundStyle">
                                                <input type="color" name="ve_backgroundColor" value="${state.ve_backgroundColor}" style="" />
                                            </div>
                                            <div class="colFontColorStyle">
                                                <input type="color" name="ve_fontColor" value="${state.ve_fontColor}" style="" />
                                            </div>
                                            <div class="colDrahNDropStyle" style="width:50px;" >
                                                <img src="${myImagesURL}Cursor-Move2-512.png" type="image/png" alt="dragNdrop" tooltip="Drap and drop to change the priority" height="20" width="20" />
                                            </div>
                                        </div>
                                    </td>
                                </tr>
                            </j:forEach>
                            <tr>
                                <td class="redips-mark" style="height:50px;background:#FFFFFF"></td>
                            </tr>
                            <tr>
                                <td class="redips-trash"  title="Trash">Drag &amp; drop here to delete the row</td>
                            </tr>
                        </table>
                    </div>		
                    <div >
                        <input  type="button" value="${%Add row}" onclick="addRow('stateList')" class="redips-trash" tooltip="Apply and refresh the page to priorize the new state" />  
                    </div>
                </div>
            </form>
        </f:entry>
         
    </f:section>
    
    <!--Job gathering-->
    <f:section title="${%Job gathering}">
        <j:forEach var="prefix" items="${from.prefixesSeparators}">
            <j:set var="content" value="${content} ${prefix}"/>
        </j:forEach>
        <f:entry title="${%Prefixes used}" field="prefixesSeparators"  help="${helpURL}?.html">
            <f:textbox name="prefixesSeparators" tooltip="Set separators values separate per spaces" value="${content}"/>
        </f:entry>
    </f:section>
  
    
    <script type="text/javascript">
        /*
        Copyright (c) 2008-2011, www.redips.net All rights reserved.
        Code licensed under the BSD License: http://www.redips.net/license/
        http://www.redips.net/javascript/drag-and-drop-table-content/
        Version 5.1.0
        Mar 06, 2015.
        */
        var REDIPS = REDIPS || {};
        REDIPS.drag = function() {
        var u, F, M, Ea, Qa, Ra, ga, ha, ma, Fa, Ga, Y, na, Ha, T, oa, ba, Ia, G, y, N, pa, qa, ra, Ja, sa, Ka, I, B, La, ia, ja, ta, Sa, Ta, Ma, ua, va, wa, ka, Na, Ua, xa, Va, r = null,
        J = 0,
        K = 0,
        ya = null,
        za = null,
        O = [],
        w = null,
        P = 0,
        Q = 0,
        R = 0,
        S = 0,
        U = 0,
        V = 0,
        ca, f = [],
        da, Aa, t, W = [],
        q = [],
        C = null,
        H = null,
        Z = 0,
        aa = 0,
        Wa = 0,
        Xa = 0,
        la = !1,
        Oa = !1,
        ea = !1,
        Ba = [],
        Ca, l = null,
        x = null,
        D = null,
        h = null,
        z = null,
        L = null,
        m = null,
        E = null,
        X = null,
        k = !1,
        p = !1,
        v = &quot;cell&quot;,
        Da = {
        div: [],
        cname: &quot;redips-only&quot;,
        other: &quot;deny&quot;
        },
        Ya = {
        action: &quot;deny&quot;,
        cname: &quot;redips-mark&quot;,
        exception: []
        },
        n = {},
        Za = {
        keyDiv: !1,
        keyRow: !1,
        sendBack: !1,
        drop: !1
        };
        M = function() {
        return !1
        };
        u = function(a) {
        var b, c, d, e, g;
        f.length = 0;
        e = void 0 === a ? C.getElementsByTagName(&quot;table&quot;) : document.querySelectorAll(a);
        for (b = a = 0; a &lt; e.length; a++)
        if (!(&quot;redips_clone&quot; === e[a].parentNode.id || -1 &lt; e[a].className.indexOf(&quot;redips-nolayout&quot;))) {
        c = e[a].parentNode;
        d = 0;
        do &quot;TD&quot; === c.nodeName &amp;&amp; d++, c = c.parentNode; while (c &amp;&amp; c !== C);
        f[b] = e[a];
        f[b].redips || (f[b].redips = {});
        f[b].redips.container = C;
        f[b].redips.nestedLevel = d;
        f[b].redips.idx = b;
        Ba[b] = 0;
        d = f[b].getElementsByTagName(&quot;td&quot;);
        c =
        0;
        for (g = !1; c &lt; d.length; c++)
        if (1 &lt; d[c].rowSpan) {
        g = !0;
        break
        }
        f[b].redips.rowspan = g;
        b++
        }
        a = 0;
        for (e = da = 1; a &lt; f.length; a++)
        if (0 === f[a].redips.nestedLevel) {
        f[a].redips.nestedGroup = e;
        f[a].redips.sort = 100 * da;
        c = f[a].getElementsByTagName(&quot;table&quot;);
        for (b = 0; b &lt; c.length; b++) - 1 &lt; c[b].className.indexOf(&quot;redips-nolayout&quot;) || (c[b].redips.nestedGroup = e, c[b].redips.sort = 100 * da + c[b].redips.nestedLevel);
        e++;
        da++
        }
        };
        Ea = function(a) {
        var b = a || window.event,
        c, d;
        if (!0 === this.redips.animated) return !0;
        b.cancelBubble = !0;
        b.stopPropagation &amp;&amp;
        b.stopPropagation();
        Oa = b.shiftKey;
        a = b.which ? b.which : b.button;
        if (Ka(b) || !b.touches &amp;&amp; 1 !== a) return !0;
        if (window.getSelection) window.getSelection().removeAllRanges();
        else if (document.selection &amp;&amp; &quot;Text&quot; === document.selection.type) try {
        document.selection.empty()
        } catch (e) {}
        b.touches ? (a = Z = b.touches[0].clientX, d = aa = b.touches[0].clientY) : (a = Z = b.clientX, d = aa = b.clientY);
        Wa = a;
        Xa = d;
        la = !1;
        REDIPS.drag.objOld = p = k || this;
        REDIPS.drag.obj = k = this;
        ea = -1 &lt; k.className.indexOf(&quot;redips-clone&quot;);
        REDIPS.drag.tableSort &amp;&amp; Ra(k);
        C !== k.redips.container &amp;&amp;
        (C = k.redips.container, u()); - 1 === k.className.indexOf(&quot;row&quot;) ? REDIPS.drag.mode = v = &quot;cell&quot; : (REDIPS.drag.mode = v = &quot;row&quot;, REDIPS.drag.obj = k = ka(k));
        y();
        ea || &quot;cell&quot; !== v || (k.style.zIndex = 999);
        l = h = m = null;
        T();
        D = x = l;
        L = z = h;
        X = E = m;
        REDIPS.drag.td.source = n.source = B(&quot;TD&quot;, k);
        REDIPS.drag.td.current = n.current = n.source;
        REDIPS.drag.td.previous = n.previous = n.source;
        &quot;cell&quot; === v ? REDIPS.drag.event.clicked(n.current) : REDIPS.drag.event.rowClicked(n.current);
        if (null === l || null === h || null === m)
        if (T(), D = x = l, L = z = h, X = E = m, null === l || null === h ||
        null === m) return !0;
        Aa = t = !1;
        REDIPS.event.add(document, &quot;mousemove&quot;, ha);
        REDIPS.event.add(document, &quot;touchmove&quot;, ha);
        REDIPS.event.add(document, &quot;mouseup&quot;, ga);
        REDIPS.event.add(document, &quot;touchend&quot;, ga);
        k.setCapture &amp;&amp; k.setCapture();
        null !== l &amp;&amp; null !== h &amp;&amp; null !== m &amp;&amp; (ca = Ia(l, h, m));
        c = I(f[D], &quot;position&quot;);
        &quot;fixed&quot; !== c &amp;&amp; (c = I(f[D].parentNode, &quot;position&quot;));
        c = G(k, c);
        r = [d - c[0], c[1] - a, c[2] - d, a - c[3]];
        C.onselectstart = function(a) {
        b = a || window.event;
        if (!Ka(b)) return b.shiftKey &amp;&amp; document.selection.clear(), !1
        };
        return !1
        };
        Qa = function(a) {
        REDIPS.drag.event.dblClicked()
        };
        Ra = function(a) {
        var b;
        b = B(&quot;TABLE&quot;, a).redips.nestedGroup;
        for (a = 0; a &lt; f.length; a++) f[a].redips.nestedGroup === b &amp;&amp; (f[a].redips.sort = 100 * da + f[a].redips.nestedLevel);
        f.sort(function(a, b) {
        return b.redips.sort - a.redips.sort
        });
        da++
        };
        ka = function(a, b) {
        var c, d, e, g, f, A;
        if (&quot;DIV&quot; === a.nodeName) return g = a, a = B(&quot;TR&quot;, a), void 0 === a.redips &amp;&amp; (a.redips = {}), a.redips.div = g, a;
        d = a;
        void 0 === d.redips &amp;&amp; (d.redips = {});
        a = B(&quot;TABLE&quot;, a);
        ea &amp;&amp; t &amp;&amp; (g = d.redips.div, g.className = xa(g.className.replace(&quot;redips-clone&quot;, &quot;&quot;)));
        c = a.cloneNode(!0);
        ea &amp;&amp;
        t &amp;&amp; (g.className += &quot; redips-clone&quot;);
        e = c.rows.length - 1;
        g = &quot;animated&quot; === b ? 0 === e : !0;
        for (f = e; 0 &lt;= f; f--)
        if (f !== d.rowIndex) {
        if (!0 === g &amp;&amp; void 0 === b)
        for (e = c.rows[f], A = 0; A &lt; e.cells.length; A++)
        if (-1 &lt; e.cells[A].className.indexOf(&quot;redips-rowhandler&quot;)) {
        g = !1;
        break
        }
        c.deleteRow(f)
        }
        t || (d.redips.emptyRow = g);
        c.redips = {};
        c.redips.container = a.redips.container;
        c.redips.sourceRow = d;
        Ua(d, c.rows[0]);
        Ja(d, c.rows[0]);
        document.getElementById(&quot;redips_clone&quot;).appendChild(c);
        d = G(d, &quot;fixed&quot;);
        c.style.position = &quot;fixed&quot;;
        c.style.top = d[0] + &quot;px&quot;;
        c.style.left = d[3] + &quot;px&quot;;
        c.style.width = d[1] - d[3] + &quot;px&quot;;
        return c
        };
        Na = function(a, b, c) {
        var d = !1,
        e, g, Pa, A, h, m, fa, q;
        q = function(a) {
        var b;
        void 0 !== a.redips &amp;&amp; a.redips.emptyRow ? wa(a, &quot;empty&quot;, REDIPS.drag.style.rowEmptyColor) : (b = B(&quot;TABLE&quot;, a), b.deleteRow(a.rowIndex))
        };
        void 0 === c ? c = k : d = !0;
        e = c.redips.sourceRow;
        g = e.rowIndex;
        Pa = B(&quot;TABLE&quot;, e);
        A = e.parentNode;
        a = f[a];
        b &gt; a.rows.length - 1 &amp;&amp; (b = a.rows.length - 1);
        h = a.rows[b];
        m = b;
        fa = h.parentNode;
        b = c.getElementsByTagName(&quot;tr&quot;)[0];
        c.parentNode.removeChild(c);
        !1 !== REDIPS.drag.event.rowDroppedBefore(Pa,
        g) &amp;&amp; (!d &amp;&amp; -1 &lt; n.target.className.indexOf(REDIPS.drag.trash.className) ? t ? REDIPS.drag.event.rowDeleted() : REDIPS.drag.trash.questionRow ? confirm(REDIPS.drag.trash.questionRow) ? (q(e), REDIPS.drag.event.rowDeleted()) : (delete p.redips.emptyRow, REDIPS.drag.event.rowUndeleted()) : (q(e), REDIPS.drag.event.rowDeleted()) : (m &lt; a.rows.length ? l === D ? g &gt; m ? fa.insertBefore(b, h) : fa.insertBefore(b, h.nextSibling) : &quot;after&quot; === REDIPS.drag.rowDropMode ? fa.insertBefore(b, h.nextSibling) : fa.insertBefore(b, h) : (fa.appendChild(b), h = a.rows[0]),
        h &amp;&amp; h.redips &amp;&amp; h.redips.emptyRow ? a.deleteRow(h.rowIndex) : &quot;overwrite&quot; === REDIPS.drag.rowDropMode ? q(h) : &quot;switch&quot; !== REDIPS.drag.rowDropMode || t || (A.insertBefore(h, e), void 0 !== e.redips &amp;&amp; delete e.redips.emptyRow), !d &amp;&amp; t || q(e), delete b.redips.emptyRow, d || REDIPS.drag.event.rowDropped(b, Pa, g)), 0 &lt; b.getElementsByTagName(&quot;table&quot;).length &amp;&amp; u())
        };
        Ua = function(a, b) {
        var c, d, e, g = [],
        f = [];
        g[0] = a.getElementsByTagName(&quot;input&quot;);
        g[1] = a.getElementsByTagName(&quot;textarea&quot;);
        g[2] = a.getElementsByTagName(&quot;select&quot;);
        f[0] = b.getElementsByTagName(&quot;input&quot;);
        f[1] = b.getElementsByTagName(&quot;textarea&quot;);
        f[2] = b.getElementsByTagName(&quot;select&quot;);
        for (c = 0; c &lt; g.length; c++)
        for (d = 0; d &lt; g[c].length; d++) switch (e = g[c][d].type, e) {
        case &quot;text&quot;:
        case &quot;textarea&quot;:
        case &quot;password&quot;:
        f[c][d].value = g[c][d].value;
        break;
        case &quot;radio&quot;:
        case &quot;checkbox&quot;:
        f[c][d].checked = g[c][d].checked;
        break;
        case &quot;select-one&quot;:
        f[c][d].selectedIndex = g[c][d].selectedIndex;
        break;
        case &quot;select-multiple&quot;:
        for (e = 0; e &lt; g[c][d].options.length; e++) f[c][d].options[e].selected = g[c][d].options[e].selected
        }
        };
        ga = function(a) {
        var b =
        a || window.event,
        c, d, e;
        a = b.clientX;
        e = b.clientY;
        U = V = 0;
        k.releaseCapture &amp;&amp; k.releaseCapture();
        REDIPS.event.remove(document, &quot;mousemove&quot;, ha);
        REDIPS.event.remove(document, &quot;touchmove&quot;, ha);
        REDIPS.event.remove(document, &quot;mouseup&quot;, ga);
        REDIPS.event.remove(document, &quot;touchend&quot;, ga);
        C.onselectstart = null;
        Ga(k);
        ya = document.documentElement.scrollWidth;
        za = document.documentElement.scrollHeight;
        U = V = 0;
        if (!t || &quot;cell&quot; !== v || null !== l &amp;&amp; null !== h &amp;&amp; null !== m)
        if (null === l || null === h || null === m) REDIPS.drag.event.notMoved();
        else {
        l &lt; f.length ?
        (b = f[l], REDIPS.drag.td.target = n.target = b.rows[h].cells[m], ba(l, h, m, ca), c = l, d = h) : null === x || null === z || null === E ? (b = f[D], REDIPS.drag.td.target = n.target = b.rows[L].cells[X], ba(D, L, X, ca), c = D, d = L) : (b = f[x], REDIPS.drag.td.target = n.target = b.rows[z].cells[E], ba(x, z, E, ca), c = x, d = z);
        if (&quot;row&quot; === v)
        if (Aa)
        if (D === c &amp;&amp; L === d) {
        b = k.getElementsByTagName(&quot;tr&quot;)[0];
        p.style.backgroundColor = b.style.backgroundColor;
        for (a = 0; a &lt; b.cells.length; a++) p.cells[a].style.backgroundColor = b.cells[a].style.backgroundColor;
        k.parentNode.removeChild(k);
        delete p.redips.emptyRow;
        t ? REDIPS.drag.event.rowNotCloned() : REDIPS.drag.event.rowDroppedSource(n.target)
        } else Na(c, d);
        else REDIPS.drag.event.rowNotMoved();
        else if (t || la)
        if (t &amp;&amp; D === l &amp;&amp; L === h &amp;&amp; X === m) k.parentNode.removeChild(k), --W[p.id], REDIPS.drag.event.notCloned();
        else if (t &amp;&amp; !1 === REDIPS.drag.clone.drop &amp;&amp; (a &lt; b.redips.offset[3] || a &gt; b.redips.offset[1] || e &lt; b.redips.offset[0] || e &gt; b.redips.offset[2])) k.parentNode.removeChild(k), --W[p.id], REDIPS.drag.event.notCloned();
        else if (-1 &lt; n.target.className.indexOf(REDIPS.drag.trash.className)) k.parentNode.removeChild(k),
        REDIPS.drag.trash.question ? setTimeout(function() {
        confirm(REDIPS.drag.trash.question) ? Fa() : (t || (f[D].rows[L].cells[X].appendChild(k), y()), REDIPS.drag.event.undeleted())
        }, 20) : Fa();
        else if (&quot;switch&quot; === REDIPS.drag.dropMode)
        if (a = REDIPS.drag.event.droppedBefore(n.target), !1 === a) ma(!1);
        else {
        k.parentNode.removeChild(k);
        b = n.target.getElementsByTagName(&quot;div&quot;);
        c = b.length;
        for (a = 0; a &lt; c; a++) void 0 !== b[0] &amp;&amp; (REDIPS.drag.objOld = p = b[0], n.source.appendChild(p), Y(p));
        ma();
        c &amp;&amp; REDIPS.drag.event.switched()
        } else &quot;overwrite&quot; ===
        REDIPS.drag.dropMode ? (a = REDIPS.drag.event.droppedBefore(n.target), !1 !== a &amp;&amp; ja(n.target)) : a = REDIPS.drag.event.droppedBefore(n.target), ma(a);
        else REDIPS.drag.event.notMoved();
                &quot;cell&quot; === v &amp;&amp; 0 &lt; k.getElementsByTagName(&quot;table&quot;).length &amp;&amp; u();
        y();
        REDIPS.drag.event.finish()
        } else k.parentNode.removeChild(k), --W[p.id], REDIPS.drag.event.notCloned();
        x = z = E = null
        };
        ma = function(a) {
        var b = null,
        c;
        if (!1 !== a) {
        if (!0 === Za.sendBack) {
        a = n.target.getElementsByTagName(&quot;DIV&quot;);
        for (c = 0; c &lt; a.length; c++)
        if (k !== a[c] &amp;&amp; 0 === k.id.indexOf(a[c].id)) {
        b =
        a[c];
        break
        }
        if (b) {
        sa(b, 1);
        k.parentNode.removeChild(k);
        return
        }
        }
            &quot;shift&quot; !== REDIPS.drag.dropMode || !Va(n.target) &amp;&amp; &quot;always&quot; !== REDIPS.drag.shift.after || ta(n.source, n.target);
            &quot;top&quot; === REDIPS.drag.multipleDrop &amp;&amp; n.target.hasChildNodes() ? n.target.insertBefore(k, n.target.firstChild) : n.target.appendChild(k);
        Y(k);
        REDIPS.drag.event.dropped(n.target);
        t &amp;&amp; (REDIPS.drag.event.clonedDropped(n.target), sa(p, -1))
        } else t &amp;&amp; k.parentNode &amp;&amp; k.parentNode.removeChild(k)
        };
        Y = function(a, b) {
        !1 === b ? (a.onmousedown = null, a.ontouchstart = null,
        a.ondblclick = null) : (a.onmousedown = Ea, a.ontouchstart = Ea, a.ondblclick = Qa)
        };
        Ga = function(a) {
        a.style.top = &quot;&quot;;
        a.style.left = &quot;&quot;;
        a.style.position = &quot;&quot;;
        a.style.zIndex = &quot;&quot;
        };
        Fa = function() {
        var a;
        t &amp;&amp; sa(p, -1);
        if (&quot;shift&quot; === REDIPS.drag.dropMode &amp;&amp; (&quot;delete&quot; === REDIPS.drag.shift.after || &quot;always&quot; === REDIPS.drag.shift.after)) {
        switch (REDIPS.drag.shift.mode) {
        case &quot;vertical2&quot;:
        a = &quot;lastInColumn&quot;;
        break;
        case &quot;horizontal2&quot;:
        a = &quot;lastInRow&quot;;
        break;
        default:
        a = &quot;last&quot;
        }
        ta(n.source, La(a, n.source)[2])
        }
        REDIPS.drag.event.deleted(t)
        };
        ha = function(a) {
        a =
        a || window.event;
        var b = REDIPS.drag.scroll.bound,
        c, d, e, g;
        a.touches ? (d = Z = a.touches[0].clientX, e = aa = a.touches[0].clientY) : (d = Z = a.clientX, e = aa = a.clientY);
        c = Math.abs(Wa - d);
        g = Math.abs(Xa - e);
        if (!Aa) {
        if (&quot;cell&quot; === v &amp;&amp; (ea || !0 === REDIPS.drag.clone.keyDiv &amp;&amp; Oa)) REDIPS.drag.objOld = p = k, REDIPS.drag.obj = k = ra(k, !0), t = !0, REDIPS.drag.event.cloned();
        else {
        if (&quot;row&quot; === v) {
        if (ea || !0 === REDIPS.drag.clone.keyRow &amp;&amp; Oa) t = !0;
        REDIPS.drag.objOld = p = k;
        REDIPS.drag.obj = k = ka(k);
        k.style.zIndex = 999
        }
        k.setCapture &amp;&amp; k.setCapture();
        k.style.position =
                    &quot;fixed&quot;;
        y();
        T();
                &quot;row&quot; === v &amp;&amp; (t ? REDIPS.drag.event.rowCloned() : REDIPS.drag.event.rowMoved())
        }
        oa();
        d &gt; J - r[1] &amp;&amp; (k.style.left = J - (r[1] + r[3]) + &quot;px&quot;);
        e &gt; K - r[2] &amp;&amp; (k.style.top = K - (r[0] + r[2]) + &quot;px&quot;)
        }
        Aa = !0;
        &quot;cell&quot; === v &amp;&amp; (7 &lt; c || 7 &lt; g) &amp;&amp; !la &amp;&amp; (la = !0, oa(), REDIPS.drag.event.moved(t));
        d &gt; r[3] &amp;&amp; d &lt; J - r[1] &amp;&amp; (k.style.left = d - r[3] + &quot;px&quot;);
        e &gt; r[0] &amp;&amp; e &lt; K - r[2] &amp;&amp; (k.style.top = e - r[0] + &quot;px&quot;);
        d &lt; H[1] &amp;&amp; d &gt; H[3] &amp;&amp; e &lt; H[2] &amp;&amp; e &gt; H[0] &amp;&amp; 0 === U &amp;&amp; 0 === V &amp;&amp; (q.containTable || d &lt; q[3] || d &gt; q[1] || e &lt; q[0] || e &gt; q[2]) &amp;&amp; (T(), na());
        if (REDIPS.drag.scroll.enable)
        for (P = b - (J / 2 &gt; d ? d - r[3] :
        J - d - r[1]), 0 &lt; P ? (P &gt; b &amp;&amp; (P = b), c = N()[0], P *= d &lt; J / 2 ? -1 : 1, 0 &gt; P &amp;&amp; 0 &gt;= c || 0 &lt; P &amp;&amp; c &gt;= ya - J || 0 !== U++ || (REDIPS.event.remove(window, &quot;scroll&quot;, y), pa(window))) : P = 0, Q = b - (K / 2 &gt; e ? e - r[0] : K - e - r[2]), 0 &lt; Q ? (Q &gt; b &amp;&amp; (Q = b), c = N()[1], Q *= e &lt; K / 2 ? -1 : 1, 0 &gt; Q &amp;&amp; 0 &gt;= c || 0 &lt; Q &amp;&amp; c &gt;= za - K || 0 !== V++ || (REDIPS.event.remove(window, &quot;scroll&quot;, y), qa(window))) : Q = 0, g = 0; g &lt; O.length; g++)
        if (c = O[g], c.autoscroll &amp;&amp; d &lt; c.offset[1] &amp;&amp; d &gt; c.offset[3] &amp;&amp; e &lt; c.offset[2] &amp;&amp; e &gt; c.offset[0]) {
        R = b - (c.midstX &gt; d ? d - r[3] - c.offset[3] : c.offset[1] - d - r[1]);
        0 &lt; R ? (R &gt; b &amp;&amp; (R = b), R *= d &lt; c.midstX ? -1 : 1, 0 === U++ &amp;&amp; (REDIPS.event.remove(c.div,
                        &quot;scroll&quot;, y), pa(c.div))) : R = 0;
        S = b - (c.midstY &gt; e ? e - r[0] - c.offset[0] : c.offset[2] - e - r[2]);
        0 &lt; S ? (S &gt; b &amp;&amp; (S = b), S *= e &lt; c.midstY ? -1 : 1, 0 === V++ &amp;&amp; (REDIPS.event.remove(c.div, &quot;scroll&quot;, y), qa(c.div))) : S = 0;
        break
        } else R = S = 0;
        a.cancelBubble = !0;
        a.stopPropagation &amp;&amp; a.stopPropagation()
        };
        na = function() {
        l &lt; f.length &amp;&amp; (l !== x || h !== z || m !== E) &amp;&amp; (null !== x &amp;&amp; null !== z &amp;&amp; null !== E &amp;&amp; (ba(x, z, E, ca), REDIPS.drag.td.previous = n.previous = f[x].rows[z].cells[E], REDIPS.drag.td.current = n.current = f[l].rows[h].cells[m], &quot;switching&quot; === REDIPS.drag.dropMode &amp;&amp; &quot;cell&quot; ===
        v &amp;&amp; (ia(n.current, n.previous), y(), T()), &quot;cell&quot; === v ? REDIPS.drag.event.changed(n.current) : &quot;row&quot; !== v || l === x &amp;&amp; h === z || REDIPS.drag.event.rowChanged(n.current)), oa())
        };
        Ha = function() {
        &quot;number&quot; === typeof window.innerWidth ? (J = window.innerWidth, K = window.innerHeight) : document.documentElement &amp;&amp; (document.documentElement.clientWidth || document.documentElement.clientHeight) ? (J = document.documentElement.clientWidth, K = document.documentElement.clientHeight) : document.body &amp;&amp; (document.body.clientWidth || document.body.clientHeight) &amp;&amp;
        (J = document.body.clientWidth, K = document.body.clientHeight);
        ya = document.documentElement.scrollWidth;
        za = document.documentElement.scrollHeight;
        y()
        };
        T = function() {
        var a, b, c, d, e, g;
        c = [];
        a = function() {
        null !== x &amp;&amp; null !== z &amp;&amp; null !== E &amp;&amp; (l = x, h = z, m = E)
        };
        b = Z;
        g = aa;
        for (l = 0; l &lt; f.length; l++)
        if (!1 !== f[l].redips.enabled &amp;&amp; (c[0] = f[l].redips.offset[0], c[1] = f[l].redips.offset[1], c[2] = f[l].redips.offset[2], c[3] = f[l].redips.offset[3], void 0 !== f[l].sca &amp;&amp; (c[0] = c[0] &gt; f[l].sca.offset[0] ? c[0] : f[l].sca.offset[0], c[1] = c[1] &lt; f[l].sca.offset[1] ?
        c[1] : f[l].sca.offset[1], c[2] = c[2] &lt; f[l].sca.offset[2] ? c[2] : f[l].sca.offset[2], c[3] = c[3] &gt; f[l].sca.offset[3] ? c[3] : f[l].sca.offset[3]), c[3] &lt; b &amp;&amp; b &lt; c[1] &amp;&amp; c[0] &lt; g &amp;&amp; g &lt; c[2])) {
        c = f[l].redips.row_offset;
        for (h = 0; h &lt; c.length - 1; h++)
        if (void 0 !== c[h]) {
        q[0] = c[h][0];
        if (void 0 !== c[h + 1]) q[2] = c[h + 1][0];
        else
        for (d = h + 2; d &lt; c.length; d++)
        if (void 0 !== c[d]) {
        q[2] = c[d][0];
        break
        } if (g &lt;= q[2]) break
        }
        d = h;
        h === c.length - 1 &amp;&amp; (q[0] = c[h][0], q[2] = f[l].redips.offset[2]);
        do
        for (m = e = f[l].rows[h].cells.length - 1; 0 &lt;= m &amp;&amp; !(q[3] = c[h][3] + f[l].rows[h].cells[m].offsetLeft,
        q[1] = q[3] + f[l].rows[h].cells[m].offsetWidth, q[3] &lt;= b &amp;&amp; b &lt;= q[1]); m--); while (f[l].redips.rowspan &amp;&amp; -1 === m &amp;&amp; 0 &lt; h--);
        0 &gt; h || 0 &gt; m ? a() : h !== d &amp;&amp; (q[0] = c[h][0], q[2] = q[0] + f[l].rows[h].cells[m].offsetHeight, (g &lt; q[0] || g &gt; q[2]) &amp;&amp; a());
        b = f[l].rows[h].cells[m];
        q.containTable = 0 &lt; b.childNodes.length &amp;&amp; 0 &lt; b.getElementsByTagName(&quot;table&quot;).length;
        if (-1 === b.className.indexOf(REDIPS.drag.trash.className))
        if (g = -1 &lt; b.className.indexOf(REDIPS.drag.only.cname), !0 === g) {
        if (-1 === b.className.indexOf(Da.div[k.id])) {
        a();
        break
        }
        } else if (void 0 !==
        Da.div[k.id] &amp;&amp; &quot;deny&quot; === Da.other) {
        a();
        break
        } else if (g = -1 &lt; b.className.indexOf(REDIPS.drag.mark.cname), (!0 === g &amp;&amp; &quot;deny&quot; === REDIPS.drag.mark.action || !1 === g &amp;&amp; &quot;allow&quot; === REDIPS.drag.mark.action) &amp;&amp; -1 === b.className.indexOf(Ya.exception[k.id])) {
        a();
        break
        }
        g = -1 &lt; b.className.indexOf(&quot;redips-single&quot;);
        if (&quot;cell&quot; === v) {
        if ((&quot;single&quot; === REDIPS.drag.dropMode || g) &amp;&amp; 0 &lt; b.childNodes.length) {
        if (1 === b.childNodes.length &amp;&amp; 3 === b.firstChild.nodeType) break;
        g = !0;
        for (d = b.childNodes.length - 1; 0 &lt;= d; d--)
        if (b.childNodes[d].className &amp;&amp; -1 &lt; b.childNodes[d].className.indexOf(&quot;redips-drag&quot;)) {
        g = !1;
        break
        }
        if (!g &amp;&amp; null !== x &amp;&amp; null !== z &amp;&amp; null !== E &amp;&amp; (D !== l || L !== h || X !== m)) {
        a();
        break
        }
        }
        if (-1 &lt; b.className.indexOf(&quot;redips-rowhandler&quot;)) {
        a();
        break
        }
        if (b.parentNode.redips &amp;&amp; b.parentNode.redips.emptyRow) {
        a();
        break
        }
        }
        break
        }
        };
        oa = function() {
        l &lt; f.length &amp;&amp; null !== l &amp;&amp; null !== h &amp;&amp; null !== m &amp;&amp; (ca = Ia(l, h, m), ba(l, h, m), x = l, z = h, E = m)
        };
        ba = function(a, b, c, d) {
        if (&quot;cell&quot; === v &amp;&amp; la) c = f[a].rows[b].cells[c].style, c.backgroundColor = void 0 === d ? REDIPS.drag.hover.colorTd : d.color[0].toString(), void 0 !== REDIPS.drag.hover.borderTd &amp;&amp; (void 0 === d ? c.border =
        REDIPS.drag.hover.borderTd : (c.borderTopWidth = d.top[0][0], c.borderTopStyle = d.top[0][1], c.borderTopColor = d.top[0][2], c.borderRightWidth = d.right[0][0], c.borderRightStyle = d.right[0][1], c.borderRightColor = d.right[0][2], c.borderBottomWidth = d.bottom[0][0], c.borderBottomStyle = d.bottom[0][1], c.borderBottomColor = d.bottom[0][2], c.borderLeftWidth = d.left[0][0], c.borderLeftStyle = d.left[0][1], c.borderLeftColor = d.left[0][2]));
        else if (&quot;row&quot; === v)
        for (a = f[a].rows[b], b = 0; b &lt; a.cells.length; b++) c = a.cells[b].style, c.backgroundColor =
        void 0 === d ? REDIPS.drag.hover.colorTr : d.color[b].toString(), void 0 !== REDIPS.drag.hover.borderTr &amp;&amp; (void 0 === d ? l === D ? h &lt; L ? c.borderTop = REDIPS.drag.hover.borderTr : c.borderBottom = REDIPS.drag.hover.borderTr : &quot;before&quot; === REDIPS.drag.rowDropMode ? c.borderTop = REDIPS.drag.hover.borderTr : c.borderBottom = REDIPS.drag.hover.borderTr : (c.borderTopWidth = d.top[b][0], c.borderTopStyle = d.top[b][1], c.borderTopColor = d.top[b][2], c.borderBottomWidth = d.bottom[b][0], c.borderBottomStyle = d.bottom[b][1], c.borderBottomColor = d.bottom[b][2]))
        };
        Ia = function(a, b, c) {
        var d = {
        color: [],
        top: [],
        right: [],
        bottom: [],
        left: []
        },
        e = function(a, b) {
        var c = &quot;border&quot; + b + &quot;Style&quot;,
        d = &quot;border&quot; + b + &quot;Color&quot;;
        return [I(a, &quot;border&quot; + b + &quot;Width&quot;), I(a, c), I(a, d)]
        };
        if (&quot;cell&quot; === v) c = f[a].rows[b].cells[c], d.color[0] = c.style.backgroundColor, void 0 !== REDIPS.drag.hover.borderTd &amp;&amp; (d.top[0] = e(c, &quot;Top&quot;), d.right[0] = e(c, &quot;Right&quot;), d.bottom[0] = e(c, &quot;Bottom&quot;), d.left[0] = e(c, &quot;Left&quot;));
        else
        for (a = f[a].rows[b], b = 0; b &lt; a.cells.length; b++) c = a.cells[b], d.color[b] = c.style.backgroundColor, void 0 !== REDIPS.drag.hover.borderTr &amp;&amp;
        (d.top[b] = e(c, &quot;Top&quot;), d.bottom[b] = e(c, &quot;Bottom&quot;));
        return d
        };
        G = function(a, b, c) {
        var d = 0,
        e = 0,
        g = a;
        &quot;fixed&quot; !== b &amp;&amp; (d = 0 - Ca[0], e = 0 - Ca[1]);
        if (void 0 === c || !0 === c) {
        do d += a.offsetLeft - a.scrollLeft, e += a.offsetTop - a.scrollTop, a = a.offsetParent; while (a &amp;&amp; &quot;BODY&quot; !== a.nodeName)
        } else {
        do d += a.offsetLeft, e += a.offsetTop, a = a.offsetParent; while (a &amp;&amp; &quot;BODY&quot; !== a.nodeName)
        }
        return [e, d + g.offsetWidth, e + g.offsetHeight, d]
        };
        y = function() {
        var a, b, c, d;
        Ca = N();
        for (a = 0; a &lt; f.length; a++) {
        c = [];
        d = I(f[a], &quot;position&quot;);
            &quot;fixed&quot; !== d &amp;&amp; (d = I(f[a].parentNode,
                &quot;position&quot;));
        for (b = f[a].rows.length - 1; 0 &lt;= b; b--) &quot;none&quot; !== f[a].rows[b].style.display &amp;&amp; (c[b] = G(f[a].rows[b], d));
        f[a].redips.offset = G(f[a], d);
        f[a].redips.row_offset = c
        }
        H = G(C);
        for (a = 0; a &lt; O.length; a++) d = I(O[a].div, &quot;position&quot;), b = G(O[a].div, d, !1), O[a].offset = b, O[a].midstX = (b[1] + b[3]) / 2, O[a].midstY = (b[0] + b[2]) / 2
        };
        N = function() {
        var a, b;
        &quot;number&quot; === typeof window.pageYOffset ? (a = window.pageXOffset, b = window.pageYOffset) : document.body &amp;&amp; (document.body.scrollLeft || document.body.scrollTop) ? (a = document.body.scrollLeft,
        b = document.body.scrollTop) : document.documentElement &amp;&amp; (document.documentElement.scrollLeft || document.documentElement.scrollTop) ? (a = document.documentElement.scrollLeft, b = document.documentElement.scrollTop) : a = b = 0;
        return [a, b]
        };
        pa = function(a) {
        var b, c;
        b = Z;
        c = aa;
        0 &lt; U &amp;&amp; (y(), T(), b &lt; H[1] &amp;&amp; b &gt; H[3] &amp;&amp; c &lt; H[2] &amp;&amp; c &gt; H[0] &amp;&amp; na());
        &quot;object&quot; === typeof a &amp;&amp; (w = a);
        w === window ? (a = N()[0], b = ya - J, c = P) : (a = w.scrollLeft, b = w.scrollWidth - w.clientWidth, c = R);
        0 &lt; U &amp;&amp; (0 &gt; c &amp;&amp; 0 &lt; a || 0 &lt; c &amp;&amp; a &lt; b) ? (w === window ? (window.scrollBy(c, 0), N(), a = parseInt(k.style.left,
        10), isNaN(a)) : w.scrollLeft += c, setTimeout(pa, REDIPS.drag.scroll.speed)) : (REDIPS.event.add(w, &quot;scroll&quot;, y), U = 0, q = [0, 0, 0, 0])
        };
        qa = function(a) {
        var b, c;
        b = Z;
        c = aa;
        0 &lt; V &amp;&amp; (y(), T(), b &lt; H[1] &amp;&amp; b &gt; H[3] &amp;&amp; c &lt; H[2] &amp;&amp; c &gt; H[0] &amp;&amp; na());
        &quot;object&quot; === typeof a &amp;&amp; (w = a);
        w === window ? (a = N()[1], b = za - K, c = Q) : (a = w.scrollTop, b = w.scrollHeight - w.clientHeight, c = S);
        0 &lt; V &amp;&amp; (0 &gt; c &amp;&amp; 0 &lt; a || 0 &lt; c &amp;&amp; a &lt; b) ? (w === window ? (window.scrollBy(0, c), N(), a = parseInt(k.style.top, 10), isNaN(a)) : w.scrollTop += c, setTimeout(qa, REDIPS.drag.scroll.speed)) : (REDIPS.event.add(w, &quot;scroll&quot;,
        y), V = 0, q = [0, 0, 0, 0])
        };
        ra = function(a, b) {
        var c = a.cloneNode(!0),
        d = c.className,
        e, g;
        !0 === b &amp;&amp; (document.getElementById(&quot;redips_clone&quot;).appendChild(c), c.style.zIndex = 999, c.style.position = &quot;fixed&quot;, e = G(a), g = G(c), c.style.top = e[0] - g[0] + &quot;px&quot;, c.style.left = e[3] - g[3] + &quot;px&quot;);
        c.setCapture &amp;&amp; c.setCapture();
        d = d.replace(&quot;redips-clone&quot;, &quot;&quot;);
        d = d.replace(/climit(\d)_(\d+)/, &quot;&quot;);
        c.className = xa(d);
        void 0 === W[a.id] &amp;&amp; (W[a.id] = 0);
        c.id = a.id + &quot;c&quot; + W[a.id];
        W[a.id] += 1;
        Ja(a, c);
        return c
        };
        Ja = function(a, b) {
        var c = [],
        d;
        c[0] = function(a, b) {
        a.redips &amp;&amp;
        (b.redips = {}, b.redips.enabled = a.redips.enabled, b.redips.container = a.redips.container, a.redips.enabled &amp;&amp; Y(b))
        };
        c[1] = function(a, b) {
        a.redips &amp;&amp; (b.redips = {}, b.redips.emptyRow = a.redips.emptyRow)
        };
        d = function(d) {
        var g, f, A;
        f = [&quot;DIV&quot;, &quot;TR&quot;];
        g = a.getElementsByTagName(f[d]);
        f = b.getElementsByTagName(f[d]);
        for (A = 0; A &lt; f.length; A++) c[d](g[A], f[A])
        };
        if (&quot;DIV&quot; === a.nodeName) c[0](a, b);
        else if (&quot;TR&quot; === a.nodeName) c[1](a, b);
        d(0);
        d(1)
        };
        sa = function(a, b) {
        var c, d, e;
        e = a.className;
        c = e.match(/climit(\d)_(\d+)/);
        null !== c &amp;&amp; (d = parseInt(c[1],
        10), c = parseInt(c[2], 10), 0 === c &amp;&amp; 1 === b &amp;&amp; (e += &quot; redips-clone&quot;, 2 === d &amp;&amp; F(!0, a)), c += b, e = e.replace(/climit\d_\d+/g, &quot;climit&quot; + d + &quot;_&quot; + c), 0 &gt;= c &amp;&amp; (e = e.replace(&quot;redips-clone&quot;, &quot;&quot;), 2 === d ? (F(!1, a), REDIPS.drag.event.clonedEnd2()) : REDIPS.drag.event.clonedEnd1()), a.className = xa(e))
        };
        Ka = function(a) {
        var b = !1;
        a.srcElement ? (b = a.srcElement.nodeName, a = a.srcElement.className) : (b = a.target.nodeName, a = a.target.className);
        switch (b) {
        case &quot;A&quot;:
        case &quot;INPUT&quot;:
        case &quot;SELECT&quot;:
        case &quot;OPTION&quot;:
        case &quot;TEXTAREA&quot;:
        b = !0;
        break;
        default:
        b = /\bredips-nodrag\b/i.test(a)
        }
        return b
        };
        F = function(a, b) {
        var c, d, e, g = [],
        f = [],
        A, k, h, l, n = /\bredips-drag\b/i,
        m = /\bredips-noautoscroll\b/i;
        k = REDIPS.drag.style.opacityDisabled;
        !0 === a || &quot;init&quot; === a ? (A = REDIPS.drag.style.borderEnabled, h = &quot;move&quot;, l = !0) : (A = REDIPS.drag.style.borderDisabled, h = &quot;auto&quot;, l = !1);
        void 0 === b ? g = C.getElementsByTagName(&quot;div&quot;) : &quot;string&quot; === typeof b ? g = document.querySelectorAll(b) : &quot;object&quot; !== typeof b || &quot;DIV&quot; === b.nodeName &amp;&amp; -1 !== b.className.indexOf(&quot;redips-drag&quot;) ? g[0] = b : g = b.getElementsByTagName(&quot;div&quot;);
        for (d = c = 0; c &lt; g.length; c++)
        if (n.test(g[c].className)) &quot;init&quot; ===
        a || void 0 === g[c].redips ? (g[c].redips = {}, g[c].redips.container = C) : !0 === a &amp;&amp; &quot;number&quot; === typeof k ? (g[c].style.opacity = &quot;&quot;, g[c].style.filter = &quot;&quot;) : !1 === a &amp;&amp; &quot;number&quot; === typeof k &amp;&amp; (g[c].style.opacity = k / 100, g[c].style.filter = &quot;alpha(opacity=&quot; + k + &quot;)&quot;), Y(g[c], l), g[c].style.borderStyle = A, g[c].style.cursor = h, g[c].redips.enabled = l;
        else if (&quot;init&quot; === a &amp;&amp; (e = I(g[c], &quot;overflow&quot;), &quot;visible&quot; !== e)) {
        REDIPS.event.add(g[c], &quot;scroll&quot;, y);
        e = I(g[c], &quot;position&quot;);
        f = G(g[c], e, !1);
        e = !m.test(g[c].className);
        O[d] = {
        div: g[c],
        offset: f,
        midstX: (f[1] +
        f[3]) / 2,
        midstY: (f[0] + f[2]) / 2,
        autoscroll: e
        };
        f = g[c].getElementsByTagName(&quot;table&quot;);
        for (e = 0; e &lt; f.length; e++) f[e].sca = O[d];
        d++
        }
        };
        I = function(a, b) {
        var c;
        a &amp;&amp; a.currentStyle ? c = a.currentStyle[b] : a &amp;&amp; window.getComputedStyle &amp;&amp; (c = document.defaultView.getComputedStyle(a, null)[b]);
        return c
        };
        B = function(a, b, c) {
        b = b.parentNode;
        for (void 0 === c &amp;&amp; (c = 0); b;) {
        if (b.nodeName === a)
        if (0 &lt; c) c--;
        else break;
        b = b.parentNode
        }
        return b
        };
        La = function(a, b) {
        var c = B(&quot;TABLE&quot;, b),
        d, e;
        switch (a) {
        case &quot;firstInColumn&quot;:
        d = 0;
        e = b.cellIndex;
        break;
        case &quot;firstInRow&quot;:
        d =
        b.parentNode.rowIndex;
        e = 0;
        break;
        case &quot;lastInColumn&quot;:
        d = c.rows.length - 1;
        e = b.cellIndex;
        break;
        case &quot;lastInRow&quot;:
        d = b.parentNode.rowIndex;
        e = c.rows[d].cells.length - 1;
        break;
        case &quot;last&quot;:
        d = c.rows.length - 1;
        e = c.rows[d].cells.length - 1;
        break;
        default:
        d = e = 0
        }
        return [d, e, c.rows[d].cells[e]]
        };
        ia = function(a, b, c) {
        var d, e, g;
        d = function(a, b) {
        REDIPS.drag.event.relocateBefore(a, b);
        var c = REDIPS.drag.getPosition(b);
        REDIPS.drag.moveObject({
        obj: a,
        target: c,
        callback: function(a) {
        var c = REDIPS.drag.findParent(&quot;TABLE&quot;, a),
        d = c.redips.idx;
        REDIPS.drag.event.relocateAfter(a, b);
        Ba[d]--;
        0 === Ba[d] &amp;&amp; (REDIPS.drag.event.relocateEnd(), REDIPS.drag.enableTable(!0, c))
        }
        })
        };
        if (a !== b &amp;&amp; &quot;object&quot; === typeof a &amp;&amp; &quot;object&quot; === typeof b)
        if (g = a.childNodes.length, &quot;animation&quot; === c) {
        if (0 &lt; g)
        for (c = B(&quot;TABLE&quot;, b), e = c.redips.idx, REDIPS.drag.enableTable(!1, c), c = 0; c &lt; g; c++) 1 === a.childNodes[c].nodeType &amp;&amp; &quot;DIV&quot; === a.childNodes[c].nodeName &amp;&amp; (Ba[e]++, d(a.childNodes[c], b))
        } else
        for (d = c = 0; c &lt; g; c++) 1 === a.childNodes[d].nodeType &amp;&amp; &quot;DIV&quot; === a.childNodes[d].nodeName ? (e = a.childNodes[d], REDIPS.drag.event.relocateBefore(e,
        b), b.appendChild(e), e.redips &amp;&amp; !1 !== e.redips.enabled &amp;&amp; Y(e), REDIPS.drag.event.relocateAfter(e)) : d++
        };
        ja = function(a, b) {
        var c, d = [],
        e;
        if (&quot;TD&quot; === a.nodeName) {
        c = a.childNodes.length;
        if (&quot;test&quot; === b) return c = n.source === a ? void 0 : 0 === a.childNodes.length || 1 === a.childNodes.length &amp;&amp; 3 === a.firstChild.nodeType;
        for (e = 0; e &lt; c; e++) d.push(a.childNodes[0]), a.removeChild(a.childNodes[0]);
        return d
        }
        };
        ta = function(a, b) {
        var c, d, e, g, f, k, h, l, m, q, p, r, t = !1,
        u, v;
        u = function(a, b) {
        REDIPS.drag.shift.animation ? ia(a, b, &quot;animation&quot;) : ia(a, b)
        };
        v = function(a) {
            &quot;delete&quot; === REDIPS.drag.shift.overflow ? ja(a) : &quot;source&quot; === REDIPS.drag.shift.overflow ? u(a, n.source) : &quot;object&quot; === typeof REDIPS.drag.shift.overflow &amp;&amp; u(a, REDIPS.drag.shift.overflow);
        t = !1;
        REDIPS.drag.event.shiftOverflow(a)
        };
        if (a !== b) {
        f = REDIPS.drag.shift.mode;
        c = B(&quot;TABLE&quot;, a);
        d = B(&quot;TABLE&quot;, b);
        k = Sa(d);
        e = c === d ? [a.redips.rowIndex, a.redips.cellIndex] : [-1, -1];
        g = [b.redips.rowIndex, b.redips.cellIndex];
        p = d.rows.length;
        r = Ta(d);
        switch (f) {
        case &quot;vertical2&quot;:
        c = c === d &amp;&amp; a.redips.cellIndex === b.redips.cellIndex ? e : [p,
        b.redips.cellIndex
        ];
        break;
        case &quot;horizontal2&quot;:
        c = c === d &amp;&amp; a.parentNode.rowIndex === b.parentNode.rowIndex ? e : [b.redips.rowIndex, r];
        break;
        default:
        c = c === d ? e : [p, r]
        }
            &quot;vertical1&quot; === f || &quot;vertical2&quot; === f ? (f = 1E3 * c[1] + c[0] &lt; 1E3 * g[1] + g[0] ? 1 : -1, d = p, p = 0, r = 1) : (f = 1E3 * c[0] + c[1] &lt; 1E3 * g[0] + g[1] ? 1 : -1, d = r, p = 1, r = 0);
        for (c[0] !== e[0] &amp;&amp; c[1] !== e[1] &amp;&amp; (t = !0); c[0] !== g[0] || c[1] !== g[1];) h = k[c[0] + &quot;-&quot; + c[1]], c[p] += f, 0 &gt; c[p] ? (c[p] = d, c[r]--) : c[p] &gt; d &amp;&amp; (c[p] = 0, c[r]++), e = k[c[0] + &quot;-&quot; + c[1]], void 0 !== e &amp;&amp; (l = e), void 0 !== h &amp;&amp; (m = h), void 0 !== e &amp;&amp; void 0 !== m ||
        void 0 !== l &amp;&amp; void 0 !== h ? (e = -1 === l.className.indexOf(REDIPS.drag.mark.cname) ? 0 : 1, h = -1 === m.className.indexOf(REDIPS.drag.mark.cname) ? 0 : 1, t &amp;&amp; 0 === e &amp;&amp; 1 === h &amp;&amp; v(l), 1 === e ? 0 === h &amp;&amp; (q = m) : (0 === e &amp;&amp; 1 === h &amp;&amp; (m = q), u(l, m))) : t &amp;&amp; void 0 !== l &amp;&amp; void 0 === m &amp;&amp; (e = -1 === l.className.indexOf(REDIPS.drag.mark.cname) ? 0 : 1, 0 === e &amp;&amp; v(l))
        }
        };
        Sa = function(a) {
        var b = [],
        c, d = {},
        e, g, f, k, h, l, m, n;
        k = a.rows;
        for (h = 0; h &lt; k.length; h++)
        for (l = 0; l &lt; k[h].cells.length; l++) {
        c = k[h].cells[l];
        a = c.parentNode.rowIndex;
        e = c.rowSpan || 1;
        g = c.colSpan || 1;
        b[a] = b[a] || [];
        for (m =
        0; m &lt; b[a].length + 1; m++)
        if (&quot;undefined&quot; === typeof b[a][m]) {
        f = m;
        break
        }
        d[a + &quot;-&quot; + f] = c;
        void 0 === c.redips &amp;&amp; (c.redips = {});
        c.redips.rowIndex = a;
        c.redips.cellIndex = f;
        for (m = a; m &lt; a + e; m++)
        for (b[m] = b[m] || [], c = b[m], n = f; n &lt; f + g; n++) c[n] = &quot;x&quot;
        }
        return d
        };
        Ta = function(a) {
        &quot;string&quot; === typeof a &amp;&amp; (a = document.getElementById(a));
        a = a.rows;
        var b, c = 0,
        d, e;
        for (d = 0; d &lt; a.length; d++) {
        for (e = b = 0; e &lt; a[d].cells.length; e++) b += a[d].cells[e].colSpan || 1;
        b &gt; c &amp;&amp; (c = b)
        }
        return c
        };
        Ma = function(a, b) {
        var c = (b.k1 - b.k2 * a) * (b.k1 - b.k2 * a),
        d;
        a += REDIPS.drag.animation.step *
        (4 - 3 * c) * b.direction;
        d = b.m * a + b.b;
        &quot;horizontal&quot; === b.type ? (b.obj.style.left = a + &quot;px&quot;, b.obj.style.top = d + &quot;px&quot;) : (b.obj.style.left = d + &quot;px&quot;, b.obj.style.top = a + &quot;px&quot;);
        a &lt; b.last &amp;&amp; 0 &lt; b.direction || a &gt; b.last &amp;&amp; 0 &gt; b.direction ? setTimeout(function() {
        Ma(a, b)
        }, REDIPS.drag.animation.pause * c) : (Ga(b.obj), b.obj.redips &amp;&amp; (b.obj.redips.animated = !1), &quot;cell&quot; === b.mode ? (!0 === b.overwrite &amp;&amp; ja(b.targetCell), b.targetCell.appendChild(b.obj), b.obj.redips &amp;&amp; !1 !== b.obj.redips.enabled &amp;&amp; Y(b.obj)) : Na(ua(b.target[0]), b.target[1], b.obj), &quot;function&quot; ===
        typeof b.callback &amp;&amp; b.callback(b.obj))
        };
        va = function(a) {
        var b, c, d;
        b = [];
        b = c = d = -1;
        if (void 0 === a) b = l &lt; f.length ? f[l].redips.idx : null === x || null === z || null === E ? f[D].redips.idx : f[x].redips.idx, c = f[D].redips.idx, b = [b, h, m, c, L, X];
        else {
        if (a = &quot;string&quot; === typeof a ? document.getElementById(a) : a) &quot;TD&quot; !== a.nodeName &amp;&amp; (a = B(&quot;TD&quot;, a)), a &amp;&amp; &quot;TD&quot; === a.nodeName &amp;&amp; (b = a.cellIndex, c = a.parentNode.rowIndex, a = B(&quot;TABLE&quot;, a), d = a.redips.idx);
        b = [d, c, b]
        }
        return b
        };
        ua = function(a) {
        var b;
        for (b = 0; b &lt; f.length &amp;&amp; f[b].redips.idx !== a; b++);
        return b
        };
        xa = function(a) {
        void 0 !==
        a &amp;&amp; (a = a.replace(/^\s+|\s+$/g, &quot;&quot;).replace(/\s{2,}/g, &quot; &quot;));
        return a
        };
        Va = function(a) {
        var b;
        for (b = 0; b &lt; a.childNodes.length; b++)
        if (1 === a.childNodes[b].nodeType) return !0;
        return !1
        };
        wa = function(a, b, c) {
        var d, e;
        &quot;string&quot; === typeof a &amp;&amp; (a = document.getElementById(a), a = B(&quot;TABLE&quot;, a));
        if (&quot;TR&quot; === a.nodeName)
        for (a = a.getElementsByTagName(&quot;td&quot;), d = 0; d &lt; a.length; d++)
        if (a[d].style.backgroundColor = c ? c : &quot;&quot;, &quot;empty&quot; === b) a[d].innerHTML = &quot;&quot;;
        else
        for (e = 0; e &lt; a[d].childNodes.length; e++) 1 === a[d].childNodes[e].nodeType &amp;&amp; (a[d].childNodes[e].style.opacity =
        b / 100, a[d].childNodes[e].style.filter = &quot;alpha(opacity=&quot; + b + &quot;)&quot;);
        else a.style.opacity = b / 100, a.style.filter = &quot;alpha(opacity=&quot; + b + &quot;)&quot;, a.style.backgroundColor = c ? c : &quot;&quot;
        };
        return {
        obj: k,
        objOld: p,
        mode: v,
        td: n,
        hover: {
        colorTd: &quot;#E7AB83&quot;,
        colorTr: &quot;#E7AB83&quot;
        },
        scroll: {
        enable: !0,
        bound: 25,
        speed: 20
        },
        only: Da,
        mark: Ya,
        style: {
        borderEnabled: &quot;solid&quot;,
        borderDisabled: &quot;dotted&quot;,
        opacityDisabled: &quot;&quot;,
        rowEmptyColor: &quot;white&quot;
        },
        trash: {
        className: &quot;redips-trash&quot;,
        question: null,
        questionRow: null
        },
        saveParamName: &quot;p&quot;,
        dropMode: &quot;multiple&quot;,
        multipleDrop: &quot;bottom&quot;,
        clone: Za,
        animation: {
        pause: 20,
        step: 2,
        shift: !1
        },
        shift: {
        mode: &quot;horizontal1&quot;,
        after: &quot;default&quot;,
        overflow: &quot;bunch&quot;
        },
        rowDropMode: &quot;before&quot;,
        tableSort: !0,
        init: function(a) {
        var b;
        if (void 0 === a || &quot;string&quot; !== typeof a) a = &quot;redips-drag&quot;;
        C = document.getElementById(a);
        if (null === C) throw &quot;REDIPS.drag - Drag container is not set!&quot;;
        Ca = N();
        document.getElementById(&quot;redips_clone&quot;) || (a = document.createElement(&quot;div&quot;), a.id = &quot;redips_clone&quot;, a.style.width = a.style.height = &quot;1px&quot;, C.appendChild(a));
        F(&quot;init&quot;);
        u();
        Ha();
        REDIPS.event.add(window, &quot;resize&quot;,
        Ha);
        b = C.getElementsByTagName(&quot;img&quot;);
        for (a = 0; a &lt; b.length; a++) REDIPS.event.add(b[a], &quot;mousemove&quot;, M), REDIPS.event.add(b[a], &quot;touchmove&quot;, M);
        REDIPS.event.add(window, &quot;scroll&quot;, y)
        },
        initTables: u,
        enableDrag: F,
        enableTable: function(a, b) {
        var c;
        if (&quot;object&quot; === typeof b &amp;&amp; &quot;TABLE&quot; === b.nodeName) b.redips.enabled = a;
        else
        for (c = 0; c &lt; f.length; c++) - 1 &lt; f[c].className.indexOf(b) &amp;&amp; (f[c].redips.enabled = a)
        },
        cloneObject: ra,
        saveContent: function(a, b) {
        var c = &quot;&quot;,
        d, e, f, h, k, l, m, n = [],
        p = REDIPS.drag.saveParamName;
            &quot;string&quot; === typeof a &amp;&amp; (a = document.getElementById(a));
        if (void 0 !== a &amp;&amp; &quot;object&quot; === typeof a &amp;&amp; &quot;TABLE&quot; === a.nodeName) {
        d = a.rows.length;
        for (k = 0; k &lt; d; k++)
        for (e = a.rows[k].cells.length, l = 0; l &lt; e; l++)
        if (f = a.rows[k].cells[l], 0 &lt; f.childNodes.length)
        for (m = 0; m &lt; f.childNodes.length; m++) h = f.childNodes[m], &quot;DIV&quot; === h.nodeName &amp;&amp; -1 &lt; h.className.indexOf(&quot;redips-drag&quot;) &amp;&amp; (c += p + &quot;[]=&quot; + h.id + &quot;_&quot; + k + &quot;_&quot; + l + &quot;&amp;&quot;, n.push([h.id, k, l]));
        c = &quot;json&quot; === b &amp;&amp; 0 &lt; n.length ? JSON.stringify(n) : c.substring(0, c.length - 1)
        }
        return c
        },
        relocate: ia,
        emptyCell: ja,
        moveObject: function(a) {
        var b = {
        direction: 1
        },
        c, d, e, g, k, h;
        b.callback =
        a.callback;
        b.overwrite = a.overwrite;
            &quot;string&quot; === typeof a.id ? b.obj = b.objOld = document.getElementById(a.id) : &quot;object&quot; === typeof a.obj &amp;&amp; &quot;DIV&quot; === a.obj.nodeName &amp;&amp; (b.obj = b.objOld = a.obj);
        if (&quot;row&quot; === a.mode) {
        b.mode = &quot;row&quot;;
        h = ua(a.source[0]);
        k = a.source[1];
        p = b.objOld = f[h].rows[k];
        if (p.redips &amp;&amp; !0 === p.redips.emptyRow) return !1;
        b.obj = ka(b.objOld, &quot;animated&quot;)
        } else if (b.obj &amp;&amp; -1 &lt; b.obj.className.indexOf(&quot;redips-row&quot;)) {
        b.mode = &quot;row&quot;;
        b.obj = b.objOld = p = B(&quot;TR&quot;, b.obj);
        if (p.redips &amp;&amp; !0 === p.redips.emptyRow) return !1;
        b.obj = ka(b.objOld,
                    &quot;animated&quot;)
        } else b.mode = &quot;cell&quot;;
        if (&quot;object&quot; === typeof b.obj &amp;&amp; null !== b.obj) return b.obj.style.zIndex = 999, b.obj.redips &amp;&amp; C !== b.obj.redips.container &amp;&amp; (C = b.obj.redips.container, u()), h = G(b.obj), e = h[1] - h[3], g = h[2] - h[0], c = h[3], d = h[0], !0 === a.clone &amp;&amp; &quot;cell&quot; === b.mode &amp;&amp; (b.obj = ra(b.obj, !0), REDIPS.drag.event.cloned(b.obj)), void 0 === a.target ? a.target = va() : &quot;object&quot; === typeof a.target &amp;&amp; &quot;TD&quot; === a.target.nodeName &amp;&amp; (a.target = va(a.target)), b.target = a.target, h = ua(a.target[0]), k = a.target[1], a = a.target[2], k &gt; f[h].rows.length -
        1 &amp;&amp; (k = f[h].rows.length - 1), b.targetCell = f[h].rows[k].cells[a], &quot;cell&quot; === b.mode ? (h = G(b.targetCell), k = h[1] - h[3], a = h[2] - h[0], e = h[3] + (k - e) / 2, g = h[0] + (a - g) / 2) : (h = G(f[h].rows[k]), e = h[3], g = h[0]), h = e - c, a = g - d, b.obj.style.position = &quot;fixed&quot;, Math.abs(h) &gt; Math.abs(a) ? (b.type = &quot;horizontal&quot;, b.m = a / h, b.b = d - b.m * c, b.k1 = (c + e) / (c - e), b.k2 = 2 / (c - e), c &gt; e &amp;&amp; (b.direction = -1), h = c, b.last = e) : (b.type = &quot;vertical&quot;, b.m = h / a, b.b = c - b.m * d, b.k1 = (d + g) / (d - g), b.k2 = 2 / (d - g), d &gt; g &amp;&amp; (b.direction = -1), h = d, b.last = g), b.obj.redips &amp;&amp; (b.obj.redips.animated = !0),
        Ma(h, b), [b.obj, b.objOld]
        },
        shiftCells: ta,
        deleteObject: function(a) {
            &quot;object&quot; === typeof a &amp;&amp; &quot;DIV&quot; === a.nodeName ? a.parentNode.removeChild(a) : &quot;string&quot; === typeof a &amp;&amp; (a = document.getElementById(a)) &amp;&amp; a.parentNode.removeChild(a)
        },
        getPosition: va,
        rowOpacity: wa,
        rowEmpty: function(a, b, c) {
        a = document.getElementById(a).rows[b];
        void 0 === c &amp;&amp; (c = REDIPS.drag.style.rowEmptyColor);
        void 0 === a.redips &amp;&amp; (a.redips = {});
        a.redips.emptyRow = !0;
        wa(a, &quot;empty&quot;, c)
        },
        getScrollPosition: N,
        getStyle: I,
        findParent: B,
        findCell: La,
        event: {
        changed: function() {},
        clicked: function() {},
        cloned: function() {},
        clonedDropped: function() {},
        clonedEnd1: function() {},
        clonedEnd2: function() {},
        dblClicked: function() {},
        deleted: function() {},
        dropped: function() {},
        droppedBefore: function() {},
        finish: function() {},
        moved: function() {},
        notCloned: function() {},
        notMoved: function() {},
        shiftOverflow: function() {},
        relocateBefore: function() {},
        relocateAfter: function() {},
        relocateEnd: function() {},
        rowChanged: function() {},
        rowClicked: function() {},
        rowCloned: function() {},
        rowDeleted: function() {},
        rowDropped: function() {},
        rowDroppedBefore: function() {},
        rowDroppedSource: function() {},
        rowMoved: function() {},
        rowNotCloned: function() {},
        rowNotMoved: function() {},
        rowUndeleted: function() {},
        switched: function() {},
        undeleted: function() {}
        }
        }
        }();
        REDIPS.event || (REDIPS.event = function() {
        return {
        add: function(u, F, M) {
        u.addEventListener ? u.addEventListener(F, M, !1) : u.attachEvent ? u.attachEvent(&quot;on&quot; + F, M) : u[&quot;on&quot; + F] = M
        },
        remove: function(u, F, M) {
        u.removeEventListener ? u.removeEventListener(F, M, !1) : u.detachEvent ? u.detachEvent(&quot;on&quot; + F, M) : u[&quot;on&quot; + F] = null
        }
        }
        }());
    </script>
        
    <script>
        (function() {
        Behaviour.specify("#recurse", 'ListView', 0, function(e) {
        var nestedElements = $$('SPAN.nested')
        e.onclick = function() {
        nestedElements.each(function(el) {
        e.checked ? el.show() : el.hide();
        });
        }
        });
        }());	
    </script>
</j:jelly>
